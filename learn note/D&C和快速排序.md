
# 什么是分而治之（Divide And Conquer)（D&C）
假如你是一个农场主，你有块1680m x 640m的土地，现在你需要把这块土地均匀的分成方块，且分出的方块要尽可能的大。那么这时就需要D&C来解决问题
- 找出基线条件，这种条件必须尽可能的简单
- 不断将问题分解，直到符合基线条件
对于这个问题来说，我们先找出基线条件，如果这个方块一边长25米，另一边长50米，那么可使用的最大方块为25x25米。

现在需要找出递归条件，根据D&C的定义，我们首先找出这块地可容纳的最大方块，那么根据前面给出的数据可得知，我们可以从这块地中画出640x640米的方块，但是现在还剩一块640x400米的地，于是我们再重复D&C划分，最后可得到80x80米的土地。然后，反推回去，对于那片最初的土地，适用的最大方块就是80x80米

# 分而治之的工作原理
1. 找出简单基线条件
2. 确定如何缩小问题的规模，使其符合基线条件

# 分而治之在代码中的应用
首先咱得先交代一点就是我们后面即将会用到的sum函数的工作原理：
* 交代一个函数 
* 如果列表为空，则返回（）
* 如果列表不为空，则计算列表中除第一个数字外的其它数字之和，将其与第一个数字相加，再返回结果

假设给定一个数字数组【2， 4， 6】，你需要将这些数字相加，并返回结果。通常情况我们可以用循环来完成这个：


```python
def sum(arr):
    total = 0
    for x in arr:
        total += x
    return total

print(sum([1,2,3,4]))
```

    10
    

但如何用递归函数来写呢？
## 明确思路
- 找出基线条件：0不包含任何元素 --> 总和为0；1只包含一个元素 ----> 总和为7
- 每次递归调用都必须离空数组更近一步，所以我们可以用：2+sum(4,6)


```python
#给定一个list
def sum(list):
#调用sum函数
      if list == []:
#基线条件
          return 0
#递归条件
          return list[0] + sum(list[1:])
```

# 快速排序
对于快速排序来说，空数组和只包含一个元素的数组只需要原样返回值就好，根本就不用排序
```python
def quicksort(array):
     if len(array) < 2:
         return array
```
如果是两个元素的数组，就检查第一个元素是否比第二个元素小，如果不是，则将两个元素交换位置即可

对于三个及以上的元素来说，我们需要先找到个基准值，然后将三个元素与基准值相比较，再将比较的结果排序，下面是代码的实现：


```python
def quicksort(array):
    if len(array) < 2:
        # 基线条件，为空或只包含一个元素的数组是“有序”的
        return array
    # 递归条件
    low = array[0]
    # 由所有小于等于基准值的元素所组成的组数组
    less = [i for i in array[1:] if i <= low]
    # 由所有大于基准值的元素所组成的组数组
    greater = [i for i in array[1:] if i > low]
    return quicksort(less) + [low] + quicksort(greater)


print(quicksort([1,3,5,7,9,0,8,6,4,2]))
```

    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    

# 小结
- D&C将问题逐步分解，使用D&C处理列表的时候，基线条件很可能是空数组或只包含一个元素的数组
- 实现快速排序的时候，请随机选择用作基准值的元素


```python

```
