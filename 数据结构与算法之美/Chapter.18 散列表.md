
散列表的英文名叫“Hash Table”，平时叫它“哈希表”或者“Hash表”**散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来**。数据的标识叫做**键/key**或者**关键字**。将关键字转化为数组下标的映射方法叫做**散列函数**，而散列函数计算得到的值叫做**散列值**
![散列表](https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg)
散列表的时间复杂度是O(1)

散列函数：它是一个函数，可以把它定义成hash(key)，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。

散列函数的三点设计要求：
1. 散列函数计算得到的散列值是一个非负整数
2. 如果key1 = key2，那hash(key1) == hash(key2)
3. 如果key1 != key2, 那hash(key1) != hash(key2)

散列冲突：散列函数无论如何都会出现第三点设计要求冲突的问题
1. 开放寻址发 open addressing
    1. 线性探测 Linear Probing
    2. 当往散列表中插入数据时，如果某个数据经过散列函数之后，存储位置已经被占用了，那就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到位置
    ![开放寻址法线性探测插入数据](https://static001.geekbang.org/resource/image/5c/d5/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg)
    3. 在散列表中查找元素的过程类似于插入过程。通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列列表的元素和要查找的元素。如果相等，则说明就是要找的元素；否则就顺序往后查找。如果遍历到数组中的空闲位置还没有找到，则说明元素不在散列表中
    ![开放寻址法线性探测查找数据](https://static001.geekbang.org/resource/image/91/ff/9126b0d33476777e7371b96e676e90ff.jpg)
    4. 删除元素时，找到然后将其标记为特殊标记deleted。当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测
    ![开放寻址法线性探测删除数据](https://static001.geekbang.org/resource/image/fe/1d/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg)
    5. 除了线性探测法，还有另外两种探测方法：二次探测和双重散列
        1. 二次探测，跟线性探测很像，线性探测的步长是1，那它探测的下标序列就是hash(key)+0,hash(key)+1,hash(key)+2。而二次探测探测的步长就变成了原来的二次方，它的探测的下标序列就是hash(key)+0,hash(key)+1^2,hash(key)+2^2
        2. 双重序列，意思就是不仅要使用一个散列函数。使用一组散列函数hash1(key),hash2(key),hash3(key),....先用第一个散列函数，然后使用第二个，以此类推。
    6. 为了尽可能保证散列表中有一定比例的空闲槽位。使用**装载因子**来表示空位的多少。装载因子越大，说明空闲越少，冲突越多，散列表的性能下降。
        - 散列表装载因子 = 填入表的元素个数 / 散列表的长度
2. 链表法 chaining
当插入的时候，只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入时间复杂度是O(1)。当查找、删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。
![链表法](https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg)

散列表查询效率并不能笼统地说成是O(1)。它跟散列函数、装载因子、散列冲突等都有关系。

如何设计散列函数？
1. 散列函数的设计不能太复杂

过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。
2. 散列函数生成的值要尽可能随机并且均匀分布

这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。

##### 装载因子过大了怎么办？
针对散列表，当装载因子过大时，可以对于散列表进行动态扩容，重新申请一个更大的散列表，将数据搬移到新散列表中。当时在扩容中数据搬移操作要复杂的多。因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置。
![散列表的动态扩容](https://static001.geekbang.org/resource/image/67/43/67d12e07a7d673a9c1d14354ad029443.jpg)
插入一个数据，最好情况下，不需要扩容，最好时间复杂度是O(1)。最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是O(n)。用摊还分析法，均摊下，时间复杂度接近最好情况，为O(1)。

对于动态散列表，随着数据的删除，散列表的数据会越来越少，空闲空间会越来越多。

##### 如何避免低效地扩容？
为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。时间复杂度是O(1)
![分批搬移数据](https://static001.geekbang.org/resource/image/6d/cb/6d6736f986ec4b75dabc5472965fb9cb.jpg)
对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。

##### 如何选择冲突解决方法？
1. 开放寻址法
    - 优点：
        1. 散列表中的数据都存储在数组中，可以有效地利用CPU缓存加快查询速度。
        2. 散列表序列化比较简单
    - 缺点：
        1. 解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。
        2. 冲突的代价更高
    - 总结：当数据量比较小，装载因子小的时候，适合采用开放寻址法。
2. 链表法
    - 优点：
        1. 链表法对内存的利用率比开放寻址法要高。因为链表结点不需要事先申请
        2. 链表法对大装载因子的容忍度更高。只要散列函数的值随即均匀，查找效率还是比顺序查找要快的多
        3. 将链表法中的链表改造成其他高效的动态数据结构，比如跳表、红黑树。最终退化的散列表查找时间为O(logn)
        ![](https://static001.geekbang.org/resource/image/10/29/103b84d7173277c5565607b413c40129.jpg)
    - 总结：基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略。

![](https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg)

